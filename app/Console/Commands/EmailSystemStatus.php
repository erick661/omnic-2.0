<?php

namespace App\Console\Commands;

use App\Models\ImportedEmail;
use App\Models\OutboxEmail;
use App\Models\CustomerCase;
use App\Models\Communication;
use App\Models\GmailGroup;
use App\Models\User;
use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;

class EmailSystemStatus extends Command
{
    protected $signature = 'emails:status {--user-id= : Filtrar por ID de usuario espec√≠fico}';
    protected $description = 'Mostrar estado general del sistema de emails';

    public function handle()
    {
        $userId = $this->option('user-id');
        
        $this->info('üìä ESTADO DEL SISTEMA DE EMAILS');
        $this->info('=' . str_repeat('=', 50));
        
        // 1. Usuarios y grupos
        $this->showUsersAndGroups($userId);
        
        // 2. Emails importados
        $this->showImportedEmails($userId);
        
        // 3. Emails en cola de env√≠o
        $this->showOutboxEmails($userId);
        
        // 4. Casos de clientes
        $this->showCustomerCases($userId);
        
        // 5. Comunicaciones
        $this->showCommunications($userId);
        
        // 6. Estado OAuth
        $this->showOAuthStatus();
        
        return 0;
    }

    private function showUsersAndGroups($userId = null)
    {
        $this->info("\nüë• USUARIOS Y GRUPOS");
        $this->info('-' . str_repeat('-', 30));
        
        $query = User::with('assignedGmailGroups');
        if ($userId) {
            $query->where('id', $userId);
        }
        
        $users = $query->get();
        
        foreach ($users as $user) {
            $groups = $user->assignedGmailGroups;
            $this->info("üë§ {$user->name} ({$user->email}) - ID: {$user->id}");
            
            if ($groups->count() > 0) {
                foreach ($groups as $group) {
                    $status = $group->is_active ? '‚úÖ' : '‚ùå';
                    $this->info("   üìß {$status} {$group->email}");
                }
            } else {
                $this->warn("   ‚ö†Ô∏è  Sin grupos asignados");
            }
        }
        
        if (!$userId) {
            $totalGroups = GmailGroup::count();
            $activeGroups = GmailGroup::where('is_active', true)->count();
            $this->info("\nüìä Total grupos: {$totalGroups} (Activos: {$activeGroups})");
        }
    }

    private function showImportedEmails($userId = null)
    {
        $this->info("\nüì• EMAILS IMPORTADOS");
        $this->info('-' . str_repeat('-', 30));
        
        $query = ImportedEmail::query();
        if ($userId) {
            $query->where('assigned_to', $userId);
        }
        
        $statusCounts = $query->select('case_status', DB::raw('count(*) as count'))
                             ->groupBy('case_status')
                             ->pluck('count', 'case_status');
                             
        foreach ($statusCounts as $status => $count) {
            $icon = match($status) {
                'pending' => '‚è≥',
                'assigned' => 'üë§',
                'opened' => 'üìÇ',
                'in_progress' => 'üîÑ',
                'pending_closure' => '‚è∞',
                'resolved' => '‚úÖ',
                'spam_marked' => 'üóëÔ∏è',
                default => '‚ùì'
            };
            $this->info("{$icon} {$status}: {$count}");
        }
        
        if ($statusCounts->isEmpty()) {
            $this->warn('‚ö†Ô∏è  No hay emails importados');
        } else {
            $total = $statusCounts->sum();
            $this->info("üìä Total: {$total} emails");
        }
    }

    private function showOutboxEmails($userId = null)
    {
        $this->info("\nüì§ EMAILS EN COLA DE ENV√çO");
        $this->info('-' . str_repeat('-', 30));
        
        $query = OutboxEmail::query();
        if ($userId) {
            // Filtrar por emails creados por el usuario
            $query->where('created_by', $userId);
        }
        
        $statusCounts = $query->select('send_status', DB::raw('count(*) as count'))
                             ->groupBy('send_status')
                             ->pluck('count', 'send_status');
                             
        foreach ($statusCounts as $status => $count) {
            $icon = match($status) {
                'pending' => '‚è≥',
                'sending' => 'üì§',
                'sent' => '‚úÖ',
                'failed' => '‚ùå',
                default => '‚ùì'
            };
            $this->info("{$icon} {$status}: {$count}");
        }
        
        if ($statusCounts->isEmpty()) {
            $this->warn('‚ö†Ô∏è  No hay emails en cola');
        } else {
            $total = $statusCounts->sum();
            $this->info("üìä Total: {$total} emails");
        }
    }

    private function showCustomerCases($userId = null)
    {
        $this->info("\nüìÅ CASOS DE CLIENTES");
        $this->info('-' . str_repeat('-', 30));
        
        try {
            $query = CustomerCase::query();
            if ($userId) {
                $query->where('assigned_user_id', $userId);
            }
            
            $statusCounts = $query->select('status', DB::raw('count(*) as count'))
                                 ->groupBy('status')
                                 ->pluck('count', 'status');
        } catch (\Exception $e) {
            $this->warn("‚ö†Ô∏è  Error consultando casos: " . $e->getMessage());
            return;
        }
                             
        foreach ($statusCounts as $status => $count) {
            $icon = match($status) {
                'open' => 'üìÇ',
                'in_progress' => 'üîÑ',
                'resolved' => '‚úÖ',
                'closed' => 'üîí',
                default => '‚ùì'
            };
            $this->info("{$icon} {$status}: {$count}");
        }
        
        if ($statusCounts->isEmpty()) {
            $this->warn('‚ö†Ô∏è  No hay casos registrados');
        } else {
            $total = $statusCounts->sum();
            $this->info("üìä Total: {$total} casos");
            
            // Mostrar √∫ltimos 3 casos
            $recentCases = CustomerCase::orderBy('created_at', 'desc')
                                     ->limit(3);
            if ($userId) {
                $recentCases->where('assigned_user_id', $userId);
            }
            $recentCases = $recentCases->get();
            
            if ($recentCases->count() > 0) {
                $this->info("\nüìã √öltimos casos:");
                foreach ($recentCases as $case) {
                    $this->info("   {$case->case_number} - {$case->status} - {$case->created_at->format('Y-m-d H:i')}");
                }
            }
        }
    }

    private function showCommunications($userId = null)
    {
        $this->info("\nüí¨ COMUNICACIONES");
        $this->info('-' . str_repeat('-', 30));
        
        try {
            $query = Communication::query();
            if ($userId) {
                $query->whereHas('customerCase', function($q) use ($userId) {
                    $q->where('assigned_user_id', $userId);
                });
            }
            
            $typeCounts = $query->select('type', DB::raw('count(*) as count'))
                               ->groupBy('type')
                               ->pluck('count', 'type');
        } catch (\Exception $e) {
            $this->warn("‚ö†Ô∏è  Tabla de comunicaciones no disponible o sin datos");
            return;
        }
                           
        foreach ($typeCounts as $type => $count) {
            $icon = match($type) {
                'email_inbound' => 'üì•',
                'email_outbound' => 'üì§',
                'note' => 'üìù',
                default => 'üí¨'
            };
            $this->info("{$icon} {$type}: {$count}");
        }
        
        if ($typeCounts->isEmpty()) {
            $this->warn('‚ö†Ô∏è  No hay comunicaciones registradas');
        } else {
            $total = $typeCounts->sum();
            $this->info("üìä Total: {$total} comunicaciones");
        }
    }

    private function showOAuthStatus()
    {
        $this->info("\nüîê ESTADO OAUTH");
        $this->info('-' . str_repeat('-', 30));
        
        try {
            // Primero verificar base de datos
            $oauthToken = \App\Models\OAuthToken::getActiveToken('gmail');
            
            if ($oauthToken) {
                $this->info("‚úÖ Token OAuth encontrado en base de datos");
                $this->info("   üìÖ Creado: {$oauthToken->created_at->format('Y-m-d H:i:s')}");
                
                if ($oauthToken->expires_at) {
                    if ($oauthToken->isExpired()) {
                        $this->warn("   ‚ö†Ô∏è Token expirado: {$oauthToken->expires_at->format('Y-m-d H:i:s')}");
                    } elseif ($oauthToken->isExpiringSoon()) {
                        $this->warn("   ‚ö†Ô∏è Token expira pronto: {$oauthToken->expires_at->format('Y-m-d H:i:s')}");
                    } else {
                        $this->info("   ‚è∞ Expira: {$oauthToken->expires_at->format('Y-m-d H:i:s')}");
                    }
                }
                
                if ($oauthToken->scopes) {
                    $this->info("   üîë Scopes: " . implode(', ', $oauthToken->scopes));
                    
                    $requiredScopes = ['gmail.readonly', 'gmail.send'];
                    $hasScope = array_map(fn($s) => str_contains(implode(' ', $oauthToken->scopes), $s), $requiredScopes);
                    
                    if (array_reduce($hasScope, fn($carry, $item) => $carry && $item, true)) {
                        $this->info("   ‚úÖ Todos los scopes requeridos presentes");
                    } else {
                        $this->error("   ‚ùå Faltan scopes requeridos");
                    }
                }
                
                return;
            }
            
            // Fallback: verificar archivos (sistema anterior)
            $tokenPath = storage_path('app/google_oauth_token.json');
            
            if (file_exists($tokenPath)) {
                $token = json_decode(file_get_contents($tokenPath), true);
                
                if (isset($token['access_token'])) {
                    $this->info("‚úÖ Token de acceso: Presente");
                    
                    if (isset($token['expires_in'])) {
                        $expiresAt = now()->addSeconds($token['expires_in']);
                        $this->info("‚è∞ Expira: {$expiresAt->format('Y-m-d H:i:s')}");
                    }
                    
                    if (isset($token['scope'])) {
                        $scopes = explode(' ', $token['scope']);
                        $this->info("üîë Scopes:");
                        foreach ($scopes as $scope) {
                            $this->info("   - {$scope}");
                        }
                        
                        // Verificar scopes cr√≠ticos
                        $requiredScopes = ['gmail.readonly', 'gmail.send'];
                        $missingScopes = array_diff($requiredScopes, $scopes);
                        
                        if (empty($missingScopes)) {
                            $this->info("‚úÖ Todos los scopes requeridos est√°n presentes");
                        } else {
                            $this->error("‚ùå Scopes faltantes: " . implode(', ', $missingScopes));
                        }
                    }
                } else {
                    $this->error("‚ùå Token inv√°lido o corrupto");
                }
            } else {
                $this->error("‚ùå Archivo de token no encontrado");
                $this->info("üí° Ejecutar: php artisan gmail:setup-oauth");
            }
            
        } catch (\Exception $e) {
            $this->error("‚ùå Error verificando OAuth: {$e->getMessage()}");
        }
    }
}